<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>LLMNR/NBTNS Poisoning</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>LLMNR/NBTNS Poisoning</h1><br/><p><h2>Esta técnica se basa en algo similar pero sin necesidad de estar capturando la red del dominio o siquiera estar dentro</h2>.</p><p></p><p>Para esta técnica hay que entender bien dos protocolos de windows que sirven para resolver nombres DNS.</p><p></p><p>Cuando se utiliza un nombre en vez de una dirección IP como podemos ver en el siguiente comando:</p><p><div class="codebox"><pre><br /><span style="color:#729fcf;font-weight:400">ls</span> <span style="color:#000000;font-weight:700">\\</span>WS01<span style="color:#000000;font-weight:700">\</span>C$</pre></div></p><p></p><p>Debe de haber algun proceso o pieza que se encargue de resolver ese nombre porque todas las comunicaciones por debajo se realizan a nivel de IP al igual que en las páginas web.</p><p></p><p>Normalmente de esto se encarga el servicio DNS del domain controller.</p><p>Si hacemos referencia a un nombre de dominio que no existe y capturamos con wireshark:</p><p></p><p><img src="images/43-1.png" alt="images/43-1.png" /></p><p></p><p>Vemos que intenta resolverlo usando DNS y como no puede empieza a utilizar otros protocolos de windows como LLMNR (Link Local Multicast Name Resolution)</p><p>Un protocolo que manda una petición preguntando a que dirección corresponde el nombre del equipo y lo manda a una dirección multicast por IPV4 e IPV6 que se corresponde al grupo donde se encuentran todos los nodos de la red.</p><p></p><p>Y como no puede resolverlo tampoco por LLMNR utiliza NBNS (Net Bios Name Service)</p><p></p><p><img src="images/43-2.png" alt="images/43-2.png" /></p><p></p><p>Que mas o menos pregunta lo mismo.</p><p></p><p>Aprovechando esto como atacante podemos monitorizar si nos llega cualquiera de los dos protocolos que acabamos de ver y cuando llegue una la resolvemos nosotros indicando que la dirección correspondiente es la del atacante.</p><p>Intenta establecer una autenticación con nosotros y ocurre todo el proceso de autenticación con el <em>challenge</em>  y nos quedamos con los datos necesarios para el anterior proceso que vimos.</p><p></p><p></p><p></p><p>Para poder hacer este envenenamiento de estos protocolos mediante Responder:</p><p></p><p><div class="codebox"><pre><br /><span style="color:#000000;font-weight:700">sudo</span> responder -I eth0 -bP</pre></div></p><p></p><p><img src="images/43-3.png" alt="images/43-3.png" /></p><p></p><p>Esta herramienta crea varios servidores y está esperando diferentes peticiones, cuando intenten realizar una petición y no sean capaces de resolver el nombre le llegará la petición y la responderemos nosotros haciendonos pasar por el servicio original.</p><p></p><p>Ahora podemos capturar de nuevo con Wireshark y ver que ocurre si volvemos a intentar resolver un nombre que no existe:</p><p></p><p><img src="images/43-4.png" alt="images/43-4.png" /></p><p></p><p>Vemos que utiliza los protocolos MDNS y LLMNR haciendo multicasting y pregunta varias veces pero si nos fijamos, esta vez si hay alguien que le responde y si nos fijamos en la IP tanto IPV4 como IPV6 se trata de la dirección 192.268.20.129 que es de la máquina  Kali, curioso verdad?</p><p></p><p>Si suponemos que esto ha ocurrido porque el “administrador” ha intentado acceder a algún recurso compartido o workstation y se ha equivocado en el nombre al introducirlo que:</p><p></p><p><img src="images/43-5.png" alt="images/43-5.png" /></p><p></p><p>No le indica que no exista sino que no tiene acceso, por supuesto esto sería algo raro y el mensaje se puede modificar para que siga dando error por no encontrar la dirección.</p><p></p><p>Pero aun más curioso es si vamos a la máquina Kali.</p><p></p><p><img src="images/43-6.png" alt="images/43-6.png" /></p><p></p><p>Y con esto responder de forma automática ha realizado ese intercambio de <em>challenge</em> y ha obtenido los hashes que además nos proporciona en el formato para poder ser crackeados, lo pegamos como antes en un archivo y:</p><p></p><p><img src="images/43-7.png" alt="images/43-7.png" /></p><p></p><p>Todo esto se realiza para cualquier usuario que fallen dentro de la red.</p><p></p><p>Por supuesto esto no solo es si se intenta conectar desde una powershell o cmd sino que desde el propio explorador de windows si se falla se produce de igual forma:</p><p></p><p><img src="images/43-8.png" alt="images/43-8.png" /></p><p></p><p>Error tonto de poner O en vez de 0</p><p></p><p><img src="images/43-9.png" alt="images/43-9.png" /></p><p></p><p>Que nos da sus credenciales.</p><p></p><p><img src="images/43-10.png" alt="images/43-10.png" /></p><p></p><p>Todo esto nos puede permitir acceder a credenciales sin ser un usuario del dominio.</p></div>
</body>
</html>
