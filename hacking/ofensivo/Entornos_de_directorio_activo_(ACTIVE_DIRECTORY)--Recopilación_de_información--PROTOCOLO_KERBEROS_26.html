<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>PROTOCOLO KERBEROS</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>PROTOCOLO KERBEROS</h1><br/><p><h1>¿QUÉ ES KERBEROS?</h1></p><p></p><p><h3>Se trata de un protocolo de autenticación desarrollado originalmente en el </h3><strong><h3>MIT</h3></strong><h3> en 1983 para el proyecto </h3><em><h3>AHTENA</h3></em><h3> cuyos objetivos incluían la integración de:</h3><ul><li>SSO (Single sign-on)</li><li>Soporte para sistemas de archivos en red</li><li>Entorno gráfico unificado (X Windows)</li><li>Servicio de convención de nombres (como DNS)</li></ul></p><p></p><p><h1>KERBEROS Y MICROSOFT WINDOWS</h1></p><p></p><p>En este sistema la autenticación de usuarios y hosts basada en dominio se realiza a través de Kerberos.</p><p></p><p>Kerberos v5 (RFC1510) se implementó en windows server 2000 y sustituyó a NTLM (Windows NT LAN Manager) como opción de autenticación por defecto.</p><p>Actualmente NTLM se sigue utilizando como mecanismo de autenticación a nivel local de la máquina (no unidos a un domino)</p><p></p><p>Este protocolo <em><strong>Kerberos</strong></em> es el más antiguo y de uso común en la actualidad.</p><p></p><p><h1>¿CÓMO FUNCIONA KERBEROS?</h1></p><p></p><p><a href="http://web.mit.edu/kerberos/www/dialogue.html">http://web.mit.edu/kerberos/www/dialogue.html</a></p><p></p><p>Este artículo es un diálogo entre dos personas <em>Athena</em> y <em>Eurípides</em> escrita por las personas que diseñaron este protocolo en el que discuten cómo ponerle solución a un problema siendo la solución final este protocolo Kerberos.</p><p></p><p></p><p>El usuario manda un paquete plano con su <strong>USUARIO</strong> al <strong>servicio de autenticación</strong> normalmente acompañado de otro paquete con un <strong>timestap</strong> cifrado con la clave del usuario,</p><p></p><p>El servicio de autenticación comprueba si existe el usuario, si es así coge su clave o <strong>password</strong> de su base de datos, genera una nueva clave de sesión y coge también la clave del <strong>ticket Granting ticket service</strong> <ul><li>→ <em>→ TICKET GRANTING TIKET -  {sessionkey:username:address:servicename:lifespan:timestamp}</em></li></ul></p><p>Cifra esta cadena de texto con la clave del <strong>ticket Granting ticket service</strong>, una clave privada del propio servicio que el usuario no conoce. Además simultáneamente crea otro paquete adicional con <strong>SessionKey</strong>1, lo cifra con la clave <strong>privada del usuario</strong> y todo esto lo envía al usuario.</p><p></p><p>El usuario recibe la información, des-encripta el paquete con su <strong>clave privada</strong>, ahora tiene la <strong>clave de sesión</strong>, el <strong>ticket granting ticket</strong> encriptado por la clave privada del <strong>ticket Granting ticket service</strong> y su clave privada personal.</p><p></p><p>El usuario usa el <strong>ticket granting ticket</strong> para interactuar con el <strong>ticket Granting ticket service</strong> pero para que no pueda ser interceptado sin más primero se crea un <em><strong>Autenticator</strong></em><ul><li>→ <em>→ AUTHENTICATOR - {username:address} encrypted with session key</em></li></ul></p><p>Y esto lo cifra con la <strong>SessionKey</strong>1.</p><p></p><p>Esto previene que, si alguien intercepta el <em><strong>ticket granting ticket</strong></em> no pueda interactuar con el <strong>ticket Granting ticket service</strong> porque no podría componer el <em><strong>Autenticator</strong></em>, ya que para esto se necesita la <strong>SessionKey</strong> que iba anteriormente incluida en un paquete cifrado con la clave personal del usuario.</p><p></p><p>Ahora el usuario envía al <strong>ticket Granting ticket service</strong> el <em><strong>Autenticator</strong></em>  cifrado y el <em><strong>ticket granting ticket</strong></em>.</p><p></p><p>Y el <strong>ticket Granting ticket service</strong> utiliza su <strong>clave privada de servicio</strong> para descifrar el <em><strong>ticket granting ticket</strong></em>, conseguir la <strong>SessionKey</strong> y así descifrar el <em><strong>Autenticator</strong></em>, comprueba que el usuario que aparece en el <em><strong>ticket granting ticket</strong></em> es el mismo que el del <em><strong>Autenticator</strong></em> coinciden y si es así pasa la validación. </p><p></p><p>Ahora el <strong>ticket Granting ticket service</strong> crea un <strong>ticket de servicio para el sistema de ficheros</strong>. Para ello crea una nueva <strong>SessionKey</strong>2 que incluye en el <strong>ticket de servicio</strong> <strong>ficheros</strong> y este lo cifra con la clave privada del <strong>servicio de ficheros</strong>.</p><p>Esta nueva <strong>SessionKey</strong>2 la mete en otro paquete y lo cifra con la <strong>SessionKey</strong>1 que obtuvo del <em><strong>ticket granting ticket</strong></em> y que el usuario ya tiene.</p><p></p><p>Envía pues el <strong>ticket de servicio para el sistema de ficheros</strong> y el paquete <strong>SessionKey</strong>2 cifrado al usuario.</p><p></p><p>El usuario descifra la <strong>SessionKey</strong>2 con la <strong>SessionKey</strong>1, crea un nuevo <em><strong>Autenticator</strong></em> 2 e igual que antes lo cifra con la <strong>SessionKey</strong>2 que acaba de obtener. </p><p></p><p>Envia el <em><strong>Autenticator</strong></em> 2  y el <strong>ticket de servicio para el sistema de ficheros</strong> a el <strong>servicio de ficheros</strong>.</p><p></p><p>El <strong>servicio de ficheros</strong> descifra el <strong>ticket de servicio para el sistema de ficheros</strong> en el que está contenida la <strong>SessionKey</strong>2 con la que a su vez descifra el <em><strong>Autenticator</strong></em> 2, compara la información del <strong>ticket</strong> con la del <em><strong>Autenticator</strong></em> 2 y si coinciden puede validar el usuario.</p><p></p><p>Ahora si le envía los datos correspondientes al usuario.</p><p></p><p></p><p></p><p>A todo esto se le añade un paso adicional en la comunicación con el sistema de archivos ya que el servicio puede autenticar al usuario pero el usuario no puede autenticar a el servicio por lo que puede ser suplantado por un servicio falso.</p><p></p><p></p><p>En la <em><strong>autenticación </strong></em>mutua:</p><p></p><p>El usuario antes de mandar el comando para obtener el fichero del servicio, únicamente manda el <em><strong>Autenticator</strong></em> 2  y el <strong>ticket de servicio para el sistema de ficheros</strong>. </p><p>El servicio realiza todo el proceso anterior, autentica a el usuario y procede a autenticarse a si mismo. Crea un paquete con un <strong>timestamp</strong>, lo cifra con la <strong>SessionKey</strong>2 (ya que si fuese un servicio falso no podría haber obtenido esa clave) y lo envía al usuario.</p><p>El usuario descifra el paquete con el <strong>timestamp</strong> y si lo hace correctamente este verifica que el <strong>servicio</strong> <strong>es</strong> <strong>el</strong> <strong>auténtico</strong> y no un suplantador, ahora si le envía el comando para realizar uso del servicio.</p><p></p><p></p><p></p><p>Todo esto es necesario de saber porque se pueden realizar ataques a ciertos pasos y aprovechar para obtener ciertos datos, explotar el uso de los tickets, utilizarlos en nombre de otros usuarios, etc...</p><p></p><p><img src="images/26-1.png" alt="images/26-1.png" /></p></div>
</body>
</html>
